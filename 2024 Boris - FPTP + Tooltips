distributeSeatsUK = () => {
		//Only let this function run once per game.
		e.distributedseats;
		if (e.distributedseats === 1) {return;}
		e.distributedseats = 1;

		// Helper functions
		function get_state_threshold(state) {
			// input: state id of current state
			// output: float between 0.0 and 1.0, determining the minimum
			// percent to pass the states' threshold
			//if (state == 475) {return 0.1}
			//if (state == 460) {return 0}
			return 0.3;
		}

		function get_guarenteed_seats(state, c) {
			// input: state id and candidate id
			// output: int, number of seats c is guarenteed in state
			//if (state == 466 && c == 80) {return 2}
			//if (state == 460 && c == 80) {return 20}
			return 0;
		}

		// zero out national seat counts
		for(var ci = 0; ci < e.final_overall_results.length; ci++) {
			e.final_overall_results[ci].electoral_votes = 0;
		}

		//loop over each state's results
		for(var i = 0; i < e.final_state_results.length; i++) {
			var state = e.final_state_results[i].state;
			
			// Store the index of the state in the final_state_results array.
			var fsrIndex = e.final_state_results.map(f=>f.state).indexOf(state);
			
			// Store a read only copy of the state's results (for convenience)
			var stateData = e.final_state_results[fsrIndex];

			// Get the state's total popular votes and seats.
			var tot_state_votes = e.states_json[e.states_json.map(f=>f.pk).indexOf(state)].fields.popular_votes;
			var seats_left = e.states_json[e.states_json.map(f=>f.pk).indexOf(state)].fields.electoral_votes;
			
			// Begin tracking how many votes are actually competitive.
			var competitivevotes = 0;

			// First loop over each party in state
			for(var j = 0; j < stateData.result.length; j++) {
				var c = stateData.result[j].candidate;

				// Zero out seats in that state
				e.final_state_results[fsrIndex].result[j].electoral_votes = 0;

				// Count the candidate's votes if and only if they pass the state threshold
				var cur_c_votes = stateData.result[j].votes * 1.0;
				var cur_c_to_totvotes = cur_c_votes / tot_state_votes
				if (cur_c_to_totvotes >= get_state_threshold(state)) {
					competitivevotes += cur_c_votes
				}

				// Add guarenteed seats to minor parties (greens?)
				var guarenteed_seats = get_guarenteed_seats(state, c)
				if (guarenteed_seats > 0) {
					seats_left -= guarenteed_seats

					// Give the party those seats in that state.
					e.final_state_results[fsrIndex].result[j].electoral_votes += guarenteed_seats;

					// Then add the seats to the national total.
					e.final_overall_results[e.final_overall_results.map(f=>f.candidate).indexOf(c)].electoral_votes += guarenteed_seats;
				
				}

			}

			var votes_per_seat = (competitivevotes * 1.0) / seats_left

			// Second loop: Actually add seats
			for(var j = 0; j < stateData.result.length; j++) {
				// Calculate what percent of the seats should be won.
				var c = stateData.result[j].candidate;
				var cur_c_votes = stateData.result[j].votes;
				var seats = Math.floor(cur_c_votes * 1.0 / votes_per_seat)

				// Calculate your percent of votes.
				var cur_c_votes = stateData.result[j].votes * 1.0;
				var cur_c_to_totvotes = cur_c_votes / tot_state_votes

				// Add seats if there are any to add and you meet the threshold
				if (seats > 0 && cur_c_to_totvotes >= get_state_threshold(state)) {
					seats_left -= seats;

					e.final_state_results[fsrIndex].result[j].electoral_votes += seats;
					e.final_overall_results[e.final_overall_results.map(f=>f.candidate).indexOf(c)].electoral_votes += seats;
				}
			}

			// Give any remaining seats to first place. simulate FPTP biasing towards first
			if (seats_left > 0) {
				var c = stateData.result[0].candidate;
				e.final_state_results[fsrIndex].result[0].electoral_votes += seats_left;
				e.final_overall_results[e.final_overall_results.map(f=>f.candidate).indexOf(c)].electoral_votes += seats_left;
			}
		}

	}

let observerRunning = false;
let changeChartRunning = false;
let mcaHeightRunning = false;
let processedNodes = new Set();

async function handleMutations(mutationsList, observer) {
    if (observerRunning) return;
    observerRunning = true;

    // stop observing
    observer.disconnect();

    // addScrollbar
    const overallResult = document.getElementById('overall_result');
    if (overallResult && !processedNodes.has(overallResult)) {
        overallResult.style.overflow = 'auto';
        const buttons = document.querySelectorAll('#view_electoral_map, #answer_select_button, #ok_button, #final_election_map_button');
        const handleClick = () => {
            overallResult.style.overflow = 'auto';
        };
        buttons.forEach(button => button.addEventListener('click', handleClick));
        processedNodes.add(overallResult);
    }

    // changechart
    if (!changeChartRunning) {
        changeChartRunning = true;
        const elementIDs = ["overall_vote_statistics", "state_result_data_summary", "overall_details_container"];
        for(let id of elementIDs) {
            let element = document.getElementById(id);
            if (element && !processedNodes.has(element)) {
                let overallthing = element.innerHTML;
                overallthing = overallthing.replace("Electoral Votes","Allocated Seats");
                overallthing = overallthing.replace("Candidate","Party List");
                element.innerHTML = overallthing;
                processedNodes.add(element);
            }
        }
        changeChartRunning = false;
    }
 // mcaHeight
    if (!mcaHeightRunning) {
        mcaHeightRunning = true;
        let results_container = document.getElementById("results_container");
        let chart = document.getElementById("myChart");
        if (results_container && !processedNodes.has(results_container)) {
            if (!chart){
                results_container.style.height = "98%";
                results_container.style.overflow = "scroll";
            } else {
                let mca = document.getElementById("main_content_area");
                if (mca) {
                    mca.style.height = "80%";
                }
            }
            processedNodes.add(results_container);
        }
        mcaHeightRunning = false;
    }

    // Resume observing
    observer.observe(document.documentElement, { childList: true, subtree: true });
    observerRunning = false;
}

let singleObserver = new MutationObserver(handleMutations);
singleObserver.observe(document.documentElement, { childList: true, subtree: true });


campaignTrail_temp.multiple_endings=true
endingPicker = (out, totv, aa, quickstats) => {

distributeSeatsUK();

function onGameWindowChangeCandidates() {
    const resultsTableHolder = document.getElementById("overall_details_container");

    if (!resultsTableHolder || resultsTableHolder.classList.contains("done")) {
        return;
    }

    resultsTableHolder.classList.add("done");

    const resultsTable = resultsTableHolder.childNodes[3].childNodes[3].children[0];

    for (let i = 0; i < resultsTable.children.length; i++) {
        const row = resultsTable.children[i];
        let name = row.firstChild.innerText;
        row.insertCell(1);
        if (name) {
            name = name.replaceAll("-", "").trim();
        }

        if (i == 0) {
            row.children[1].innerHTML = `<span style="font-weight:bold">Party Leader</span>`;
        } else {
            row.children[1].innerHTML = vpTable[name];
        }
    }

    const resultsTableHistorical = resultsTableHolder.childNodes[5].childNodes[3].children[0];

    for (let i = 0; i < resultsTableHistorical.children.length; i++) {
        const row = resultsTableHistorical.children[i];        
        let name = row.childNodes[1].innerText;
        row.insertCell(1);
        if (name) {
            name = name.replaceAll("-", "").trim();
        }
       
        if (i == 0) {
            row.children[1].innerHTML = `<span style="font-weight:bold">Party Leader</span>`;
        } else {
            row.children[1].innerHTML = vpTableHistorical[name];
        }
    }

    // Add CSS to increase row spacing
    const styleElem = document.createElement('style');
    styleElem.textContent = `
        #overall_details_container table tr {
            line-height: 1.5; /* Adjust line height as needed */
        }
    `;
    document.head.appendChild(styleElem);
}

const gameWindowNode = document.getElementById("game_window");
const candidateWatcherConfig = { attributes: true, childList: true, subtree: true };

const candidateObserver = new MutationObserver(onGameWindowChangeCandidates);
candidateObserver.observe(gameWindowNode, candidateWatcherConfig);

function updateHistoricalData(newVpTable, newHexColors, newNames, newEvs, newPvs, newPvps) {
    vpTableHistorical = newVpTable;
    HistHexcolour = newHexColors;
    HistName = newNames;
    HistEV = newEvs;
    HistPV = newPvs;
    HistPVP = newPvps;
}



function getTooltips(str) {
        let matches = [];
    
        tooltipList.forEach((tooltip, index) => {
            // Adjust the regex to match searchString potentially surrounded by “ and followed by optional punctuation
           let regex = new RegExp(`(?<=\\b|\\s|^|“)${tooltip.searchString}(?=[.,;!?]?\\b|\\s|”|$)`, 'g');
    
    
            let match;
            while ((match = regex.exec(str)) !== null) {
                matches.push({
                    start: match.index + (match[0].startsWith('“') ? 1 : 0), // Adjust for potential starting “
                    end: match.index + match[0].length - (match[0].endsWith('”') ? 1 : 0) - (match[2] ? 1 : 0), 
                    tooltipIndex: index
                });
            }
        });
    
        // Sort by starting position; if two start at the same position, longer match comes first
        matches.sort((a, b) => a.start - b.start || b.end - b.start - (a.end - a.start));
    
        // Filter out overlaps
        for (let i = 0; i < matches.length - 1; ) {
            if (matches[i + 1].start < matches[i].end) {
                matches.splice(i + 1, 1); // Remove the next match since it overlaps
            } else {
                i++; // Move to next match
            }
        }
    
        return matches;
    }
    function applyTooltips(str) {
        const matches = getTooltips(str);
        let result = '';
        let lastIndex = 0;
    
        matches.forEach(match => {
            const tooltip = tooltipList[match.tooltipIndex];
            result += str.slice(lastIndex, match.start);
            result += `<span class='mytooltip'>${tooltip.searchString}<span class='mytooltiptext'>${tooltip.explanationText}</span></span>`;
            lastIndex = match.end;
        });
    
        result += str.slice(lastIndex); // Add the remainder of the original string
        return result;
    }
    
    function applyTooltipsToObject(obj) {
        for (let key in obj) {
            if (typeof obj[key] === 'string') {
                obj[key] = applyTooltips(obj[key]);
            } else if (typeof obj[key] === 'object') {
                applyTooltipsToObject(obj[key]); // Recursive call
            }
        }
    }
    
    applyTooltipsToObject(campaignTrail_temp.questions_json);
    applyTooltipsToObject(campaignTrail_temp.answers_json);
    applyTooltipsToObject(campaignTrail_temp.answer_feedback_json);  
