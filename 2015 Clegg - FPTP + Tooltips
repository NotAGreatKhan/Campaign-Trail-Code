distributeSeatsUK = () => {
    //Only let this function run once per game.
    e.distributedseats;
    if (e.distributedseats === 1) {return;}
    e.distributedseats = 1;

    // Helper functions
    function get_state_threshold(state) {
        // input: state id of current state
        // output: float between 0.0 and 1.0, determining the minimum
        // percent to pass the states' threshold
        //if (state == 475) {return 0.1}
        //if (state == 460) {return 0}

        // Conservative thresholds
        if (state == 21518 && c == 200) {return 0.15} // Scotland
        if (state == 21308 && c == 200) {return 0.275} // North East England
        if (state == 21329 && c == 200) {return 0.35} // North West England 
        // Labour Thresholds
        if (state == 21308 && c == 202) {return 0.099} // North East England
        if (state == 21329 && c == 202) {return 0.1} // North West England
        if (state == 21350 && c == 202) {return 0.11} // Yorkshire
        if (state == 21371 && c == 202) {return 0.11} // East Midlands
        if (state == 21392 && c == 202) {return 0.11} // West Midlands
        if (state == 21413 && c == 202) {return 0.11} // East of England
        if (state == 21434 && c == 202) {return 0.12} // London
        if (state == 21455 && c == 202) {return 0.12} // South East
        if (state == 21476 && c == 202) {return 0.12} // South West
        if (state == 21497 && c == 202) {return 0.11} // Wales
        if (state == 21518 && c == 202) {return 0.09} // Scotland
        if (state == 21539 && c == 202) {return 1} // Northern Ireland
        return 0;
    }

    function get_guarenteed_seats(state, c) {
        // input: state id and candidate id
        // output: int, number of seats c is guarenteed in state
        //if (state == 466 && c == 80) {return 2}
        //if (state == 460 && c == 80) {return 20}
        // Speaker in South East
        if (state == 21455 && c == 21194) {return 1}
        return 0;
    }

    // zero out national seat counts
    for(var ci = 0; ci < e.final_overall_results.length; ci++) {
        e.final_overall_results[ci].electoral_votes = 0;
    }

    //loop over each state's results
    for(var i = 0; i < e.final_state_results.length; i++) {
        var state = e.final_state_results[i].state;
        
        // Store the index of the state in the final_state_results array.
        var fsrIndex = e.final_state_results.map(f=>f.state).indexOf(state);
        
        // Store a read only copy of the state's results (for convenience)
        var stateData = e.final_state_results[fsrIndex];

        // Get the state's total popular votes and seats.
        var tot_state_votes = e.states_json[e.states_json.map(f=>f.pk).indexOf(state)].fields.popular_votes;
        var seats_left = e.states_json[e.states_json.map(f=>f.pk).indexOf(state)].fields.electoral_votes;
        
        // Begin tracking how many votes are actually competitive.
        var competitivevotes = 0;

        // First loop over each party in state
        for(var j = 0; j < stateData.result.length; j++) {
            var c = stateData.result[j].candidate;

            // Zero out seats in that state
            e.final_state_results[fsrIndex].result[j].electoral_votes = 0;

            // Count the candidate's votes if and only if they pass the state threshold
            var cur_c_votes = stateData.result[j].votes * 1.0;
            var cur_c_to_totvotes = cur_c_votes / tot_state_votes
            if (cur_c_to_totvotes >= get_state_threshold(state)) {
                competitivevotes += cur_c_votes
            }

            // Add guarenteed seats to minor parties (greens?)
            var guarenteed_seats = get_guarenteed_seats(state, c)
            if (guarenteed_seats > 0) {
                seats_left -= guarenteed_seats

                // Give the party those seats in that state.
                e.final_state_results[fsrIndex].result[j].electoral_votes += guarenteed_seats;

                // Then add the seats to the national total.
                e.final_overall_results[e.final_overall_results.map(f=>f.candidate).indexOf(c)].electoral_votes += guarenteed_seats;
            
            }

        }

        // By default, this is * 1.0. 

        var votes_per_seat = (competitivevotes * 0.5) / seats_left

        // Second loop: Actually add seats
        for(var j = 0; j < stateData.result.length; j++) {
            // Calculate what percent of the seats should be won.
            var c = stateData.result[j].candidate;
            var cur_c_votes = stateData.result[j].votes;
            var seats = Math.floor(cur_c_votes * 1.0 / votes_per_seat)

            // Calculate your percent of votes.
            var cur_c_votes = stateData.result[j].votes * 1.0;
            var cur_c_to_totvotes = cur_c_votes / tot_state_votes

            // Add seats if there are any to add and you meet the threshold
            if (seats > 0 && cur_c_to_totvotes >= get_state_threshold(state)) {
                seats_left -= seats;

                e.final_state_results[fsrIndex].result[j].electoral_votes += seats;
                e.final_overall_results[e.final_overall_results.map(f=>f.candidate).indexOf(c)].electoral_votes += seats;
            }
        }

        // Give any remaining seats to first place. simulate FPTP biasing towards first
        if (seats_left > 0) {
            var c = stateData.result[0].candidate;
            e.final_state_results[fsrIndex].result[0].electoral_votes += seats_left;
            e.final_overall_results[e.final_overall_results.map(f=>f.candidate).indexOf(c)].electoral_votes += seats_left;
        }
    }

}

let observerRunning = false;
let changeChartRunning = false;
let mcaHeightRunning = false;
let processedNodes = new Set();

async function handleMutations(mutationsList, observer) {
    if (observerRunning) return;
    observerRunning = true;

    // stop observing
    observer.disconnect();

    // addScrollbar
    const overallResult = document.getElementById('overall_result');
    if (overallResult && !processedNodes.has(overallResult)) {
        overallResult.style.overflow = 'auto';
        const buttons = document.querySelectorAll('#view_electoral_map, #answer_select_button, #ok_button, #final_election_map_button');
        const handleClick = () => {
            overallResult.style.overflow = 'auto';
        };
        buttons.forEach(button => button.addEventListener('click', handleClick));
        processedNodes.add(overallResult);
    }

    // changechart
    if (!changeChartRunning) {
        changeChartRunning = true;
        const elementIDs = ["overall_vote_statistics", "state_result_data_summary", "overall_details_container"];
        for(let id of elementIDs) {
            let element = document.getElementById(id);
            if (element && !processedNodes.has(element)) {
                let overallthing = element.innerHTML;
                overallthing = overallthing.replace("Electoral Votes","Allocated Seats");
                overallthing = overallthing.replace("Candidate","Party List");
                overallthing = overallthing.replace("Running Mate","Party Leader");
                element.innerHTML = overallthing;
                processedNodes.add(element);
            }
        }
        changeChartRunning = false;
    }
 // mcaHeight
    if (!mcaHeightRunning) {
        mcaHeightRunning = true;
        let results_container = document.getElementById("results_container");
        let chart = document.getElementById("myChart");
        if (results_container && !processedNodes.has(results_container)) {
            if (!chart){
                results_container.style.height = "98%";
                results_container.style.overflow = "scroll";
            } else {
                let mca = document.getElementById("main_content_area");
                if (mca) {
                    mca.style.height = "80%";
                }
            }
            processedNodes.add(results_container);
        }
        mcaHeightRunning = false;
    }

    // Resume observing
    observer.observe(document.documentElement, { childList: true, subtree: true });
    observerRunning = false;
}

let singleObserver = new MutationObserver(handleMutations);
singleObserver.observe(document.documentElement, { childList: true, subtree: true });
    

campaignTrail_temp.multiple_endings=true
endingPicker = (out, totv, aa, quickstats) => {

distributeSeatsUK();

function onGameWindowChangeCandidates() {
    const resultsTableHolder = document.getElementById("overall_details_container");

    if (!resultsTableHolder || resultsTableHolder.classList.contains("done")) {
        return;
    }

    resultsTableHolder.classList.add("done");

    const resultsTable = resultsTableHolder.childNodes[3].childNodes[3].children[0];

    for (let i = 0; i < resultsTable.children.length; i++) {
        const row = resultsTable.children[i];
        let name = row.firstChild.innerText;
        row.insertCell(1);
        if (name) {
            name = name.replaceAll("-", "").trim();
        }

        if (i == 0) {
            row.children[1].innerHTML = `<span style="font-weight:bold">Party Leader</span>`;
        } else {
            row.children[1].innerHTML = vpTable[name];
        }
    }

    const resultsTableHistorical = resultsTableHolder.childNodes[5].childNodes[3].children[0];

    for (let i = 0; i < resultsTableHistorical.children.length; i++) {
        const row = resultsTableHistorical.children[i];
        let name = row.childNodes[1].innerText;
        row.insertCell(1);
        if (name) {
            name = name.replaceAll("-", "").trim();
        }

        if (i == 0) {
            row.children[1].innerHTML = `<span style="font-weight:bold">Party Leader</span>`;
        } else {
            row.children[1].innerHTML = vpTableHistorical[name];
        }
    }

    // Add CSS to increase row spacing
    const styleElem = document.createElement('style');
    styleElem.textContent = `
        #overall_details_container table tr {
            line-height: 1.5; /* Adjust line height as needed */
        }
    `;
    document.head.appendChild(styleElem);
 }

const gameWindowNode = document.getElementById("game_window");
const candidateWatcherConfig = { attributes: true, childList: true, subtree: true };

const candidateObserver = new MutationObserver(onGameWindowChangeCandidates);
candidateObserver.observe(gameWindowNode, candidateWatcherConfig);

function updateHistoricalData(newVpTable, newHexColors, newNames, newEvs, newPvs, newPvps) {
    vpTableHistorical = newVpTable;
    HistHexcolour = newHexColors;
    HistName = newNames;
    HistEV = newEvs;
    HistPV = newPvs;
    HistPVP = newPvps;
}


construct = (a = 1) => {
	
    e.page = e.page + a < e.pages.length ? e.page + a : 0
    let html = e.header;
    html += e.pages[e.page] + "<br>";
    if (e.page > 0) {
    
    html += `<button onclick='endingConstructor(a = -1)'>Back</button>`
    }
    if (e.page < e.pages.length - 1) {
    
    html += `<button onclick='endingConstructor(a = 1)'>Next</button>`
    }
    
    for (i in e.executable) {
    if (e.executable[i][0] == e.page) {
        e.executable[i][1]();
      
    }
    }
    
    if (e.image == true)
    setTimeout(()=>{
      candImg = $(".person_image")[0]
      if (candImg) {
        candImg.remove()
      console.log("TRYING");
        $("#final_results_description")[0].style = `
          text-align:left;
          width: 72%;
        height:71%;
          display: block;
          margin-left: auto;
          margin-right: auto;
        overflow: auto;
        `
       console.log("RESULTS UPDATED");
      }
    }, 10)
    else if (e.image)
    setTimeout(()=>{
      candImg = $(".person_image")[0];
      if (candImg) {
        candImg.src = e.image;
      console.log("TRYING");
        $("#final_results_description")[0].style = `
          text-align:left;
          width: 72%;
        height:71%;
          display: block;
          margin-left: auto;
          margin-right: auto;
        overflow: auto;
        `
       console.log("RESULTS UPDATED");
      }		
    }, 10)
    
    return html;
    }
    
  endingConstructor = (a = 1) => {
    $("#final_results_description")[0].innerHTML = construct(a);
  }
    
    // ENDINGS -- this is slightly more reliable than the ending code method
    
    e.header = "<h1>Error</h1>";
    e.pages = ["<p>This is an error handler, contact u/No-Reading9991</p>"];
    e.page = 0;

    e.pages = []
    e.header = "";
    e.executable = []


if (quickstats[1] >= 324) {
} 

else if (aa[0].electoral_votes < 324 && aa[1].electoral_votes < 324 && aa[2].electoral_votes < 324 && aa[3].electoral_votes < 324 && aa[4].electoral_votes < 324 && aa[5].electoral_votes < 324 && aa[6].electoral_votes < 324 && aa[7].electoral_votes < 324 && aa[8].electoral_votes < 324 && aa[9].electoral_votes < 324 && aa[10].electoral_votes < 324 && aa[11].electoral_votes < 324 && aa[12].electoral_votes < 324 && aa[13].electoral_votes < 324) {
} 

else if (quickstats[0] >= 324 && quickstats[0]<340) {     
}

return construct(0);
}


function getTooltips(str) {
        let matches = [];
    
        tooltipList.forEach((tooltip, index) => {
            // Adjust the regex to match searchString potentially surrounded by “ and followed by optional punctuation
           let regex = new RegExp(`(?<=\\b|\\s|^|“)${tooltip.searchString}(?=[.,;!?]?\\b|\\s|”|$)`, 'g');
    
    
            let match;
            while ((match = regex.exec(str)) !== null) {
                matches.push({
                    start: match.index + (match[0].startsWith('“') ? 1 : 0), // Adjust for potential starting “
                    end: match.index + match[0].length - (match[0].endsWith('”') ? 1 : 0) - (match[2] ? 1 : 0), 
                    tooltipIndex: index
                });
            }
        });
    
        // Sort by starting position; if two start at the same position, longer match comes first
        matches.sort((a, b) => a.start - b.start || b.end - b.start - (a.end - a.start));
    
        // Filter out overlaps
        for (let i = 0; i < matches.length - 1; ) {
            if (matches[i + 1].start < matches[i].end) {
                matches.splice(i + 1, 1); // Remove the next match since it overlaps
            } else {
                i++; // Move to next match
            }
        }
    
        return matches;
    }
    function applyTooltips(str) {
        const matches = getTooltips(str);
        let result = '';
        let lastIndex = 0;
    
        matches.forEach(match => {
            const tooltip = tooltipList[match.tooltipIndex];
            result += str.slice(lastIndex, match.start);
            result += `<span class='mytooltip'>${tooltip.searchString}<span class='mytooltiptext'>${tooltip.explanationText}</span></span>`;
            lastIndex = match.end;
        });
    
        result += str.slice(lastIndex); // Add the remainder of the original string
        return result;
    }
    
    function applyTooltipsToObject(obj) {
        for (let key in obj) {
            if (typeof obj[key] === 'string') {
                obj[key] = applyTooltips(obj[key]);
            } else if (typeof obj[key] === 'object') {
                applyTooltipsToObject(obj[key]); // Recursive call
            }
        }
    }
    
    applyTooltipsToObject(campaignTrail_temp.questions_json);
    applyTooltipsToObject(campaignTrail_temp.answers_json);
    applyTooltipsToObject(campaignTrail_temp.answer_feedback_json);
